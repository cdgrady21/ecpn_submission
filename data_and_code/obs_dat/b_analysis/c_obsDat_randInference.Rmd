---
title: "obsDat_randInference"
author: "Chris Grady"
date: "12/8/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())

# data (from obsDat_analysis) ##chris: why scanning in from there? 
## to get results of quantile regression?
#load("eventsMedian.Rdata")
#load("marketMedian.Rdata")

# data from data cleaning file
load("../a_clean/a_obsDat_clean.rda")

events <- events[!events[,"eat_past"] %in% NA | !events$eat_farm %in% NA,] # remove the bad observation

# libs
library(dplyr)
library(mosaic)
library(estimatr)

# from review: check if same coefficient without israel and hadiza, who could have known about treatment assignment.
##for hell of it, check with _only_ israel and hadiza
## events
events_rb <- events[!grepl("hadiza nuhu|israel okpe", events$Observer.Name),]
events_had <- events[grepl("hadiza nuhu|israel okpe", events$Observer.Name),]

## markets
markets_rb <- markets[!grepl("hadiza nuhu|israel okpe", markets$Observer.Name),]
markets_had <- markets[grepl("hadiza nuhu|israel okpe", markets$Observer.Name),]

```

```{r}
##lm, no rand inference.
## using rank because not skewed like raw.
summary(lm(pastoralists_index_rank~treatment*time+State+site, data=markets))

# no israel/hadiza
summary(lm(pastoralists_index_rank~treatment*time+State+site, data=markets_rb))

# only israel/hadiza
## note: only went to treatment sites
mark_pasts_had <- summary(lm(pastoralists_index_rank~time, data=markets_had))$coefficients['time',c(1,4)]
```

```{r}
#Want a true pval from randomization inference.  Would use coin for speed/brevity, but don't know how to account for sites and states in coin's oneway_test, so writing a true pval function.

#To create this null distribution:
#- within state, shuffle TR assignment between sites.
#    - sites within a state are randomly assigned TR or CO

#- within site, shuffle time between observations?
#    - obs within a site are randomly assigned t1 or t2.

#Definitely need to shuffle TR between sites.  Not sure if it makes sense to randomly assign observations as pre/post.  Pretty sure that doesn't make sense, actually, since pre/post are systematically different in ways we did not randomly assign.

#True p-value function.

# shuffle tr between sites
true.fun <- function(var, nsims=5000, dat)
{
  thelm <- lm(dat[,var]~treatment*time+State+site, data=dat)
  thecoef <-coef(thelm)['treatment:time']
  
  # randomly grab 6 in nas and 4 in ben to be treated
  size_nas <- length(unique(dat$site[dat$State %in% "nasarawa" & dat$treatment %in% 1]))
  size_ben <- length(unique(dat$site[dat$State %in% "benue" & dat$treatment %in% 1]))
  rand.coef = rep(NA,nsims)
  for(i in 1:nsims){
    rand.nas <- sample(unique(dat$site[dat$State %in% "nasarawa"]), size=size_nas)
    rand.ben <- sample(unique(dat$site[dat$State %in% "benue"]), size=size_ben)
    rand <- c(as.character(rand.nas), as.character(rand.ben))
    rand.samp <- dat
    rand.samp[,'treatment'] <- ifelse(rand.samp$site %in% rand, 1, 0)
     
    lm.null <- lm(rand.samp[,var]~treatment*time+State+site, data=rand.samp)
    rand.coef[i] <- coef(lm.null)['treatment:time']
    }
  
  thep <- mean(rand.coef>=thecoef, na.rm=T)
  thedf <- data.frame(coef=thecoef,truep=thep)
  rownames(thedf) <- paste0(var, "~","ECPN")
  return(thedf)
}
#true.fun(var='pastoralists_index_rank', dat=markets)

```

# Markets

## Pastoralists

Pastoralists Index Rank

```{r}
set.seed(0528)
(mark_pasts <- true.fun(var='pastoralists_index_rank', dat=markets))
#(mark_pasts <- true.fun(var='pastoralists_index_raw', dat=markets))
```
```{r}
# without israel/hadiza
(mark_pasts_rb <- true.fun(var='pastoralists_index_rank', dat=markets_rb))
#(mark_pasts_rb <- true.fun(var='pastoralists_index_raw', dat=markets_rb))

# cannot do it with only israel/hadiza -- they only went to TR sites
```

### Components of pastoralists index -- ranked and raw

Note: don't need this, didn't finish it.

Outcomes: `r rankOutcomes[grepl("past", rankOutcomes)]`

Pastoralist buyers

```{r, eval=F}
(mark_pasts_buyers_raw <- true.fun(var='pastoralist_buyers', dat=markets))
(mark_pasts_buyers <- true.fun(var='pastoralist_buyers_rank', dat=markets))

```

Pastoralist sellers

```{r, eval=F}
(mark_pasts_sellers_raw <- true.fun(var='pastoralist_sellers', dat=markets))
(mark_pasts_sellers <- true.fun(var='pastoralist_sellers_rank', dat=markets))
```

pastoralist_women_sell_fura_rank

```{r}

```

pastoralist_nono_buyers_rank. chris: this one shouldn't be much affected.

```{r}

```


## Farmers

```{r}
set.seed(0528)
(mark_farms <- true.fun(var='farmers_index_rank', dat=markets))
#(mark_farms <- true.fun(var='farmers_index_raw', dat=markets))
```
```{r}
# without israel/hadiza
(mark_farms_rb <- true.fun(var='farmers_index_rank', dat=markets_rb))
#(mark_farms_rb <- true.fun(var='farmers_index_raw', dat=markets_rb))

#cannot do truep with only israel/hadiza -- they only went to TR sites
mark_farms_had <- summary(lm(farmers_index_rank~time, data=markets_had))$coefficients['time',c(1,4)]
```


# Events

no rand inf

```{r, eval=F}
summary(lm(outgroupPerc_index_rank~treatment*time+site, data=events))

# TR group drops by 9, CO group drops by 18.
mosaic::mean(events[events$time %in% 0 & events$treatment %in% 0, "outgroupPerc_index_rank"], na.rm=T)
mosaic::mean(events[events$time %in% 1 & events$treatment %in% 0, "outgroupPerc_index_rank"])
mosaic::mean(events[events$time %in% 0 & events$treatment %in% 1, "outgroupPerc_index_rank"])
mosaic::mean(events[events$time %in% 1 & events$treatment %in% 1, "outgroupPerc_index_rank"])


# without hadiza/israel
summary(lm(outgroupPerc_index_rank~treatment*time+site, data=events_rb))
```

*rand inf.*

Outgroup Variables. Index.

```{r}
set.seed(0528)
# need to account for total size of event, what % outgroup was
(out_ind <- true.fun(var='outgroupPerc_index_rank', dat=events))

#robustness check: alt outcome measure -- don't use rank
#(out_ind <- true.fun(var='outgroupPerc_index', dat=events))

```
```{r}
# without israel/hadiza
(out_ind_rb <- true.fun(var='outgroupPerc_index_rank', dat=events_rb))

#only israel/hadiza
out_ind_had <- summary(lm(outgroupPerc_index_rank~time, data=events_had))$coefficients['time',c(1,4)]
```

# Save

```{r}
obsDat_truePs <- rbind(mark_pasts, mark_farms, out_ind)
# fix rownames to match coefplot names (obsDat_figs.Rmd)
rownames(obsDat_truePs) <- c("pastoralists_index_rank", 
                             "farmers_index_rank",
                             "outgroup_index_rank")
save(obsDat_truePs, file="obsDat_truePs.rda")

# Save robustness check that excludes hadiza/israel
obsDat_truePs_rb <- rbind(mark_pasts_rb, mark_farms_rb, out_ind_rb)
# fix rownames to match coefplot names (obsDat_figs.Rmd)
rownames(obsDat_truePs_rb) <- c("pastoralists_index_rank_rb", 
                             "farmers_index_rank_rb",
                             "outgroup_index_rank_rb")
save(obsDat_truePs_rb, file="obsDat_truePs_rb.rda")

# Save robustness check that is only hadiza/israel
obsDat_truePs_had <- rbind(mark_pasts_had, mark_farms_had, out_ind_had)
# fix rownames to match coefplot names (obsDat_figs.Rmd)
rownames(obsDat_truePs_had) <- c("pastoralists_index_rank_had", 
                             "farmers_index_rank_had",
                             "outgroup_index_rank_had")
save(obsDat_truePs_had, file="obsDat_truePs_had.rda")
```

# Other


Outgroup variables.  Attend and eat.

```{r}
#(out_att <- true.fun(var='attend_outgroup', dat=events))
(out_att <- true.fun(var='attend_outgroup_rank', dat=events))
(out_att <- true.fun(var='attend_outgroup_presPerc', dat=events))

(out_att <- true.fun(var='eat_outgroup_rank', dat=events))
(out_att <- true.fun(var='eat_outgroup_eatPerc', dat=events))

# variable is: % of eaters who are farm/past, not % of farm/past who ate.
events[,c("attend_outgroup", "eat_outgroup", "eat_outgroup_eatPerc", 
          "eat_farm", "eat_past", "eat_farm_eatPerc", "eat_past_eatPerc")]
```

attend

```{r}
(event_att <- true.fun(var='attend_total_rank', dat=events))

true.fun(var='attend_past_presPerc', dat=events)
true.fun(var='attend_farm_presPerc', dat=events)
```

eat

```{r}
(event_eat <- true.fun(var='eat_total_rank', dat=events))

true.fun(var='eat_past_eatPerc', dat=events)
#true.fun(var='eat_farm_eatPerc', dat=events) # some infinite
```

index. Using Perc_index to account for size of gathering.

```{r}
# the Perc_index is not a count, so I don't think I need ranks.
## even though pastoralists result looks better with ranks.
(event_past <- true.fun(var='pastoralistsPerc_index', dat=events))
(event_farm <- true.fun(var='farmersPerc_index', dat=events))

```

### restrict events to things hosted by other community

```{r}
farm_host <- events[events$Host.Community %in% "farmer",]
past_host <- events[events$Host.Community %in% "pastoralist",]
```

In farmers community. Not seeing a strong pattern.  Maybe more pastoralists.

```{r}
# farmers host; care about pastoralists
true.fun(var='attend_past_presPerc', dat=farm_host)
true.fun(var='eat_past_eatPerc', dat=farm_host)
true.fun(var='pastoralistsPerc_index', dat=farm_host)
```

In pastoralists community. Also maybe a pattern of more farmers, but again not strong.

```{r}
# farmers host; care about pastoralists
true.fun(var='attend_farm_presPerc', dat=farm_host)
true.fun(var='eat_farm_eatPerc', dat=farm_host)
true.fun(var='farmersPerc_index', dat=farm_host)
```




# Misc

## See the null distribution

```{r, eval=F}
# shuffle tr between sites
null.fun <- function(var, nsims=5000, dat)
{
  thelm <- lm(dat[,var]~treatment*time+State+site, data=dat)
  thecoef <-coef(thelm)['treatment:time']
  
  # randomly grab 6 in nas and 4 in ben to be treated
  rand.coef = rep(NA,nsims)
  for(i in 1:nsims){
    rand.nas <- sample(unique(dat$site[dat$State %in% "nasarawa"]), size=6)
    rand.ben <- sample(unique(dat$site[dat$State %in% "benue"]), size=4)
    rand <- c(as.character(rand.nas), as.character(rand.ben))
    rand.samp <- dat
    rand.samp[,'treatment'] <- ifelse(rand.samp$site %in% rand, 1, 0)
     
    lm.null <- lm(rand.samp[,var]~treatment*time+State+site, data=rand.samp)
    rand.coef[i] <- coef(lm.null)['treatment:time']
    }
  
 return(rand.coef)
}

## markets
null_dist1 <- null.fun(var='pastoralists_index_rank', dat=markets)
plot(density(null_dist1))
## null distribution is bimodal?

null_dist2 <- null.fun(var='pastoralists_index', dat=markets)
plot(density(null_dist2))

## events
null_dist3 <- null.fun(var='pastoralists_index', dat=events)
plot(density(null_dist3, na.rm=T))
## some coefs are NA?

null_dist4 <- null.fun(var='attend_total', dat=events)
plot(density(null_dist4, na.rm=T))
## this one makes no damn sense.

```

Why the null distributions so weird (bimodal and/or skewed?)

```{r}
# high variance between sites
(siteVar <- tapply(markets$pastoralists_index_rank, markets$site, mean, na.rm=T))
sd(siteVar)
summary(siteVar)

```



## Different true pval function

```{r}
# also shuffle time within sites. chris: Decided this is wrong!
true.fun1 <- function(var, nsims=3000, dat)
{
  thelm <- lm(dat[,var]~treatment*time+State+site, data=dat)
  thecoef <-coef(thelm)['treatment:time']
  
  rand.coef = rep(NA,nsims)
  for(i in 1:nsims){
    # shuffle tr
    rand.nas <- sample(unique(dat$site[dat$State %in% "nasarawa"]), size=6)
    rand.ben <- sample(unique(dat$site[dat$State %in% "benue"]), size=4)
    rand <- c(as.character(rand.nas), as.character(rand.ben))
    rand.samp <- dat
    rand.samp[,'treatment'] <- ifelse(rand.samp$site %in% rand, 1, 0)
    
    # shuffle time, keeping same number of obs in t1 and t2
    rand.samp <- rand.samp %>% dplyr::group_by(site) %>%
      mutate(time=sample(time, replace=F)) %>%
      as.data.frame()
    
    lm.null <- lm(rand.samp[,var]~treatment*time+State+site, data=rand.samp)
    rand.coef[i] <- coef(lm.null)['treatment:time']
    }
  
  thep <- mean(rand.coef>=thecoef, na.rm=T)
  thedf <- data.frame(coef=thecoef,truep=thep)
  rownames(thedf) <- paste0(var, "~","ECPN")
  return(thedf)
}
#true.fun1(var='pastoralists_index_rank', dat=markets)
```
