prop.table(table(dat$one))
dat$one <- ifelse(dat$add %in% 1,1,0)
dat$bothnone <- 1-dat$one
prop.table(table(dat$one))
prop.table(table(dat$one))
ones <- dat[dat$one %in% 1,]
prop.table(table(ones$V2))
prop.table(table(dat$one))
racist <- c(rep(1,500),
rep(0,500))
jan <- c(rep(1,200),
rep(0,800))
dat <- as.data.frame(cbind(shuffle(racist), shuffle(jan)))
dat$add <- dat$V1+dat$V2
dat$one <- ifelse(dat$add %in% 1,1,0)
dat$bothnone <- 1-dat$one
prop.table(table(dat$V2))
ones <- dat[dat$one %in% 1,]
prop.table(table(ones$V2))
racist <- c(rep(1,500),
rep(0,500))
jan <- c(rep(1,200),
rep(0,800))
dat <- as.data.frame(cbind(shuffle(racist), shuffle(jan)))
dat$add <- dat$V1+dat$V2
dat$one <- ifelse(dat$add %in% 1,1,0)
dat$bothnone <- 1-dat$one
prop.table(table(dat$V2))
ones <- dat[dat$one %in% 1,]
prop.table(table(ones$V2))
prop.table(table(dat$V2))
ones <- dat[dat$one %in% 1,]
prop.table(table(ones$V2))
table(dat$one)
534*.2
534-`07`
534-107
427/534
nonsens <- 0.2
one <- 0.5
bothnone <- 1-one
one-nonsens
nonsens <- 0.2
one <- 0.5
bothnone <- 1-one
bothnone*0.5 + (one-nonsens)
nonsens <- 0.2
one <- 0.5
bothnone <- 1-one
bothnone*0.5 + (one-nonsens)
nonsens <- 0.2
one <- 0.5
bothnone <- 1-one
bothnone*0.5 + (one-nonsens)
one-nonsens
racistOnes <- 0.5*.2
racistOnes
racistOnes <- 0.5*(1-nonsens)
(racistOnes <- 0.5*(1-nonsens))
(racistOnes <- one*(1-nonsens))
(racistTwos <- bothnone*(1-nonsens)
)
(truemean <- (bothnone+nonsens-1)/(2*nonsens-1))
nonsens <- 0.2
one <- 0.5
bothnone <- 1-one
(racistOnes <- one*(1-nonsens))
(racistTwos <- bothnone*(1-nonsens))
(truemean <- (bothnone+nonsens-1)/(2*nonsens-1))
bothnone
nonsens
bothnone+nonsens-1
#
n=1000
n2=700
p2=.5
p1=.5
((n1/n)-p2)/p1
#
n=1000
n1=700
p2=.5
p1=.5
((n1/n)-p2)/p1
n1/n
(n1/n)-p2)
(n1/n)-p2
coin <- c(rep(1,500), rep(0,500))
sens <- c(rep(1,400), rep(0,600))
dat <- as.data.frame(cbind(coin,sens))
dat$reveal <- ifelse(coin %in% 1, 1, dat$sens)
table(dat$reveal)
table(dat$reveal, dat$coin)
coin <- c(rep(1,500), rep(0,500))
sens <- c(rep(1,400), rep(0,600))
dat <- as.data.frame(cbind(shuffle(coin),shuffle(sens)))
dat$reveal <- ifelse(coin %in% 1, 1, dat$sens)
table(dat$reveal)
coin <- c(rep(1,500), rep(0,500))
sens <- c(rep(1,400), rep(0,600))
dat <- as.data.frame(cbind(shuffle(coin),shuffle(sens)))
dat$reveal <- ifelse(coin %in% 1, 1, dat$sens)
head(dat)
coin <- c(rep(1,500), rep(0,500))
sens <- c(rep(1,400), rep(0,600))
dat <- as.data.frame(cbind(sample(coin),sample(sens)))
dat$reveal <- ifelse(coin %in% 1, 1, dat$sens)
head(dat)
dat <- as.data.frame(cbind(coin,sens))
head(dat)
dat$coin <- sample(dat$coin)
head(d)
head(dat)
dat$coin <- sample(dat$coin); dat$sens <- sample(dat$sens)
dat$reveal <- ifelse(coin %in% 1, 1, dat$sens)
table(dat$reveal)
.5*7
.5*.5*.5
.5^7
.1/2
.1/.5
choose(100,4)
install.packages('gtools')
library("gtools")
?permutations
permutations(100,4)
nrow(permutations(100,4))
nrow(permutations(40,4))
nrow(permutations(45,4))
1000000/500
3/15
5/15
1.4*725
750/725
150*725
8*75
6*5
2135/3
4000/700
install.packages("pandoc-crossref")
69+31
1.02^30
1.03^30
648*0.5
3+3
2322/2900
37/98
15+12+12+15+15
2019 - 1965
16000/700
16400/700
.42*700
3000*12
10*1600
(10*1600)/(5*6)
16000/(5*6*8)
3999.86-2135.81
2000-1864.05
134*775
ppl <- c(alice, basers, raj)
ppl <- c("alice", "basers", "raj")
sample(ppl)
sample(ppl)
sample(ppl)
set.seed(20200408)
set.seed(20200408)
sample(ppl)
sample(ppl)
sample(ppl)
set.seed(20200408)
sample(ppl)
set.seed(20200408)
sample(ppl)
1864.05+6734.8
4000/30
80000/180
480/60
150*.01
220*5.45
?rep
rep(1,4)
x <- c(rep(1,4),rep(0,29))
sample(x,5)
test <- do(1000)*sample(x,5)
test <- mosaic::do(1000)*sample(x,5)
test[1:5]
test$yes <- rowsum(test[,])
test$yes <- rowSums(test[,])
head(test)
tail(test)
test$yes <- ifelse(test$yes>0,1,0)
mean(test$yes)
test <- mosaic::do(1000)*sample(x,10)
test$yes <- rowSums(test[,])
test$yes <- ifelse(test$yes>0,1,0)
mean(test$yes)
bag <- (1,0,0,-1,-1,-2,-2,-3,-3,-4,-5,-2,-2,-3,-5)
bag <- c(1,0,0,-1,-1,-2,-2,-3,-3,-4,-5,-2,-2,-3,-5)
mean(bag)
twos <- do(10000)*sample(bag,2)
library(mosaic)
?sample
twos <- do(10000)*sample(bag,2)
head(twos)
bag <- c(1,1,0,0,-1,-1,-1,-2,-2,-3,-3,-4,-5,-2,-2,-3,-5)
mean(bag)
twos <- do(10000)*sample(bag,2)
twos$r <- max(twos[,1:2])
head(twos)
twos$r <- apply(twos[,1:2],1,max)
head(twos)
mean(twos$r)
bag <- c(1,1,0,0,-1,-1,-1,-2,-2,-3,-3,-4,-5,0,0,-3,-5)
mean(bag)
twos <- do(10000)*sample(bag,2)
twos$r <- apply(twos[,1:2],1,max)
mean(twos$r)
4*8
4*7
1/9
1/8
1/44
1/150
30*8
200/8
2000/30
25*8*5
15*8*5
48/3
550000/75000000
550000/30000000
150/2500
2650/2500
3359.51*26
3500*2
7000*12
240/8
install.packages(c("dplyr", "estimatr", "googlesheets4", "knitr", "mosaic", "qdap", "sentimentr", "tm"))
library(mosaic)
install.packages(stringi)
install.packages("stringi")
1500/122
122*6
24/70
143/.34
400/7
450/7
230*7
1610-900
780+900
1680/7
130*5
650/60
70*8
rm(list=ls())
library(readtext)
library(quanteda)
library(stringi)
install.packages("quanteda")
install.packages("quanteda")
library(readtext)
library(quanteda)
install.packages("Rcpp")
install.packages("Rcpp")
library(quanteda)
library(stringi)
88/12
42/8
3000*52
.05*3000
.5*(1-.5)/1000
.9*(1-.9)/1000
99/14
600*2
600*2
2400+300
2300-600
1700/2
a <- c("chris", "nuole", "levi")
b <- c("wei", "wu", "shu")
rbind(a,sampl(b))
rbind(a,sample(b))
set.seed(47623)
rbind(a,sample(b))
set.seed(47623)
rbind(a,sample(b))
set.seed(47622)
rbind(a,sample(b))
set.seed(47623)
rbind(a,sample(b))
50*2*6
500/600
161/7
113/4
500/8
a <- c("chris", "nuole", "levi")
b <- c("wei", "wu", "shu")
a <- c("chris", "nuole", "levi")
b <- c("wei", "wu", "shu")
set.seed(0801264)
rbind(a,sample(b))
a <- c("chris", "nuole", "levi")
b <- c("wei", "wu", "shu")
set.seed(782022)
rbind(a,sample(b))
a <- c("chris", "nuole", "levi")
b <- c("wei", "wu", "shu")
set.seed(8202022)
rbind(a,sample(b))
set.seed(20082022)
rbind(a,sample(b))
a <- c("chris", "nuole", "levi")
b <- c("wei", "wu", "shu")
set.seed(20082022)
rbind(a,sample(b))
3797.06*26
1000000*1.05^30
R. version
R.version
install.packages("rmarkdown")
tinytex::uninstall_tinytex()
remove.packages("tinytex")
sample(c("wonder", "sushi"))
sample(c("wonder", "sushi"),1)
sample(c("wonder", "sushi"),1)
set.seed(272023)
sample(c("wonder", "sushi"),1)
set.seed(20230207)
sample(c("wonder", "sushi"),1)
set.seed(20230207)
sample(c("wonder", "sushi"),1)
set.seed(20230207)
sample(c("wonder", "sushi"),1)
71.96/48
53.97/36
setwd("C:/Users/chris/Repos/ecpn_submission/data_and_code/obs_dat/b_analysis")
setwd("C:/Users/chris/Repos/ecpn_submission/data_and_code/obs_dat/a_clean")
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
events <- read.csv("../raw/ecpn_events.csv")
markets <- read.csv("../raw/ecpn_markets.csv")
library(lubridate)
library(dplyr)
library(estimatr)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
events <- read.csv("../raw/ecpn_events.csv")
markets <- read.csv("../raw/ecpn_markets.csv")
library(lubridate)
library(dplyr)
library(estimatr)
# Chunk 2
# clean white space, make lower case
markets$Community.Name <- trimws(tolower(markets$Community.Name))
markets$site <- markets$Community.Name
# make outcomes numeric
outcomes <- names(markets)[grepl("(market|farm|past)", names(markets))]
markets[,outcomes] <- sapply(markets[,outcomes], function(x) {as.numeric(as.character(x))}) # warning is fine, just making empty cells like <NA> into NA.
# fix treatment assignment
#tapply(markets$treatment, markets$site, mean)
markets[markets$site %in% "ushata", "treatment"] <- 0
# fix state
markets[markets$site %in% "sabon gida agan", "State"] <- "benue"
# Chunk 3
# dichotomous before/after
##july 2016 - feb 2017
## sept 2017 - end
class(markets$date.of.observation..M.D.Y.)
markets$date <- lubridate::mdy(markets$date.of.observation..M.D.Y.)
markets$time <- ifelse(markets$date > "2017-03-01", 1, 0)
# date as numeric with 0 as first month and max(month) as last month
## make a "month" variable
markets$month <- sub("-[0-9]*$", "", markets$date)
table(markets$Community.Name, markets$month)
markets$month_num <- car::recode(as.character(markets$month),
"'2016-07'=0;
'2016-08'=1;
'2016-09'=2;
'2016-10'=3;
'2016-11'=4;
'2016-12'=5;
'2017-01'=6;
'2017-02'=7;
'2017-09'=14;
'2017-10'=15;
'2017-11'=16;
'2017-12'=17")
#03=8, 04=9, 05=10, 06=11, 07=12, 08=13
# Chunk 5
# rank the outcomes
# Rank-based outcomes since the raw outcomes are everywhere
## separate t1-t2 ranks
rankOutcomes <- paste0(outcomes, "_rank")
markets[, rankOutcomes] <- NA
markets[markets$time %in% 0,rankOutcomes] <- sapply(markets[markets$time %in% 0,outcomes], dense_rank)
markets[markets$time %in% 1,rankOutcomes] <- sapply(markets[markets$time %in% 1,outcomes], dense_rank)
#summary(markets[,rankOutcomes])
## combined -- I don't like this, don't want outcomes at t1 ranked with outcomes at t2.
#rankOutcomes <- paste0(outcomes, "_rank")
#markets[, rankOutcomes] <- NA
#markets[,rankOutcomes] <- sapply(markets[,outcomes], dense_rank)
# make sure ranked works
markets[order(markets$pastoralist_sellers),c("pastoralist_sellers", "pastoralist_sellers_rank")][1:10,]
# Chunk 6
# Make a "pastoralist" index and a "Farmer" index
### Rank
markPastor <- names(markets)[grepl("pastor", names(markets))]
markPastor_rank <- markPastor[grepl("_rank", markPastor)]
markets$pastoralists_index_rank <- rowMeans(markets[,markPastor_rank], na.rm=T) # remove NA?
markFarmers <- names(markets)[grepl("farm", names(markets))]
markFarmers_rank <- markFarmers[grepl("_rank", markFarmers)]
markets$farmers_index_rank <- rowMeans(markets[,markFarmers_rank], na.rm=T) # remove NA?
# Chunk 7
### Raw outcome (but cut above 95th percentile because crazy right-skew)
#sapply(markets[outcomes], function(x) quantile(x, seq(0,1,0.05), na.rm=T))
markets[,outcomes] <- lapply(markets[,outcomes], function(x){
ifelse(x>quantile(x, 0.95, na.rm=T), quantile(x, 0.95, na.rm=T), x)
})
#sapply(markets[outcomes], function(x) quantile(x, seq(0,1,0.05), na.rm=T))
markPastor_raw <- markPastor[!grepl("_rank", markPastor)]
markets$pastoralists_index_raw <- rowMeans(markets[,markPastor_raw], na.rm=T) # remove NA?
markFarmers_raw <- markFarmers[!grepl("_rank", markFarmers)]
markets$farmers_index_raw <- rowMeans(markets[,markFarmers_raw], na.rm=T) # remove NA?
# Revise outcome list to include the indices
outcomes <- names(markets)[grepl("(market|farm|past)", names(markets))]
# Chunk 8
# get rid of nothing columns
events <- events[,!grepl("^X", names(events))]
#lower case all non-numerics
typeList <- sapply(events, class)
lowNames <- names(typeList)[!typeList %in% "integer"]
events[,names(events) %in% lowNames] <- as.data.frame(sapply(events[,names(events) %in% lowNames], tolower))
sapply(events[,names(events) %in% lowNames]
names(events) %in% lowNames
names(events)[names(events) %in% lowNames]
#trim white space
events[,names(events) %in% lowNames] <- as.data.frame(sapply(events[,names(events) %in% lowNames], trimws))
sapply(events[,names(events) %in% lowNames]
events[,names(events) %in% lowNames]
# chris: if events has "marriage|wedding" in the level, just make it "marriage"
# chris: since so few events are not naming ceremonies and weddings, make "other" category.
events$event_type1 <- as.factor(events$event_type)
levels(events$event_type1) <- c("Other", "Marriage", "Marriage", "Naming", 'Other', "Marriage")
# check treatment assignment and state
#tapply(events$treatment, events$site, mean)
events[events$Community.Name %in% "torkula", "State"] <- "benue"
# what's up with totals?
events$test <- events$attend_farm + events$attend_past
test <- events[!events$test %in% events$attend_total,]
test[,c(10:12,20)]
events$test1 <- events$eat_farm + events$eat_past
test <- events[!events$test1 %in% events$eat_total,]
test[,c(13:15,21)]
## making "attend_total" the sum of attend_farm and attend_past in the 7 cases it is slightly different.
events$attend_total <- events$test
events$eat_total <- events$test1
events[,c('test', 'test1')] <- NULL
rm(test)
# dichotomous before/after
##july 2016 - feb 2017
## sept 2017 - end
class(events$date.of.observation..M.D.Y.)
events$date <- lubridate::mdy(events$date.of.observation..M.D.Y.)
events$time <- ifelse(events$date > "2017-03-01", 1, 0)
# site
events$site <- events$Community.Name
# date as numeric with 0 as first month and max(month) as last month
## make a "month" variable
events$month <- sub("-[0-9]*$", "", events$date)
table(events$Community.Name, events$month)
events$month_num <- car::recode(as.character(events$month),
"'2016-07'=0;
'2016-08'=1;
'2016-09'=2;
'2016-10'=3;
'2016-11'=4;
'2016-12'=5;
'2017-01'=6;
'2017-02'=7;
'2017-09'=14;
'2017-10'=15;
'2017-11'=16;
'2017-12'=17")
# make outcomes numeric
eventOutcomes <- names(events)[grepl("(attend|eat)_", names(events))]
events[,eventOutcomes] <- sapply(events[,eventOutcomes], function(x) {as.numeric(as.character(x))}) # i think is already integer
# make pastoralist/farmers index outcomes - attend_grp, eat_grp
eventPastor <- names(events)[grepl("past", names(events))]
events$pastoralists_index <- rowMeans(events[,eventPastor])
eventFarmers <- names(events)[grepl("farm", names(events))]
events$farmers_index <- rowMeans(events[,eventFarmers])
# remake outcomes obj
eventOutcomes <- names(events)[grepl("(attend|eat)_|index", names(events))]
# make percentage outcomes: % of attendees who were farm/past & % of eaters who were farm/past
## sort of a farmers/pastoralists "per capita" variable
events[,paste0(eventOutcomes[2:3],"_presPerc")] <- events[,eventOutcomes[2:3]]/events[,eventOutcomes[1]]
events[,paste0(eventOutcomes[5:6],"_eatPerc")] <- events[,eventOutcomes[5:6]]/events[,eventOutcomes[4]]
# make perc index
eventPastorp <- names(events)[grepl("past_(pres|eat)Perc", names(events))]
events$pastoralistsPerc_index <- rowMeans(events[,eventPastorp])
eventFarmerp <- names(events)[grepl("farm_(pres|eat)Perc", names(events))]
events$farmersPerc_index <- rowMeans(events[,eventFarmerp])
# add %s to "eventOutcomes"
eventOutcomes <- names(events)[grepl("(attend|eat)_|index", names(events))]
#rank outcomes
events[,paste0(eventOutcomes, "_rank")] <- sapply(events[,eventOutcomes], dense_rank)
rankEventOutcomes <- paste0(eventOutcomes, "_rank")
summary(events[,eventOutcomes])
eventPastor
names(events)
table(events$Host.Community)
