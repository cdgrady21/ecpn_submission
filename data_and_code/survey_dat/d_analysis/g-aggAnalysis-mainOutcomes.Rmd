---
title: "g-aggAnalysis for academic paper"
output:
  word_document:
    toc: yes
  pdf_document:
    number_sections: yes
    toc: yes
  html_document:
    df_print: paged
    toc: yes
---

<!--Chris: notes

Want to replace all lm() with lm_lin() but lm_lin() does not allow me to vary treatment in a function.-->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(962022)
rm(list=ls())
load("../c_creating_dataframes/f-aggregateComms_ap.Rdata")
load("../c_creating_dataframes/rand_df.Rdata")

#True p-value function.  Don't need covariate adjustment to absorb error.  True p's Especially necessary with community level analysis, because we have a small number of clusters.  Treatment assigned at PSU level.
load("true_fun.rda")

library(NPC)
library(dplyr)
library(mosaic)
library(estimatr)
library(robustbase)
library(quantreg)
library(sandwich)
library(clubSandwich)
library(lmtest)
library(coin)

# Subsets
## Look at farmers and pastoralists separately.

farmers <- ag.df[grepl(".farmers", ag.df$comm),]
pastors <- ag.df[grepl(".pastor", ag.df$comm),]

## Look at states separately.
nas <- ag.df[ag.df$state %in% "nas",]
ben <- ag.df[ag.df$state %in% "ben",]

```

# Variable list

- Attitudes: attitude
- Insecurity: in
- Coordination: pgp_donate, pgp_amount, 
- Contact: contactOnly, randExp/percExp, market/social observation
- Affect: endorsement experiment

# Testing Outcomes

We will use the differencing strategy when treatment and control are not balanced at baseline.  We will use the controlling-for strategy when treatment and control are balanced at baseline.  We say the groups are balanced if they are within 0.2 SDs of eachother at baseline.

true.fun1 is with differencing. true.fun is controlling-for. strat.fun tells us which to use.


************

# Make a table of all outcomes with coefs and pvalues for the diff ways of making indices and estimating models.

- Rows as outcomes; columns for CW-Cont, CW-diff, Ind-Cont, Ind-diff; each column shows coef & pvalue.

- index: inverse-covariance weights ("cw") or additive ("ind")
- model: controlling-for ("cont") or differencing ("diff")

```{r}
analysis.fun <- function(var)
{
  if(paste0(var, "_cw_end") %in% names(ag.df))
  {
    var_cw_cont <- true.fun(paste0(var, "_cw"), 'treatment')
    var_ind_cont <- true.fun(paste0(var, "_index"), 'treatment')
    var_cw_diff <- true.fun1(paste0(var, "_cw"), 'treatment')
    var_ind_diff <- true.fun1(paste0(var, "_index"), 'treatment')
    
    which1 <- strat.fun(paste0(var, "_cw_base"))
    thebase <- ifelse(grepl("Contr", which1), "cw_cont", "cw_diff")
  }
  else if(grepl("pgp", var))
  {
    var_cw_cont <- true.fun(var, 'treatment')
    var_ind_cont <- NA
    var_cw_diff <- NA
    var_ind_diff <- NA
    which1 <- NA
    thebase <- NA
  }
  else
  {
    var_cw_cont <- true.fun(var, 'treatment')
    var_ind_cont <- NA
    var_cw_diff <- true.fun1(var, 'treatment')
    var_ind_diff <- NA
    
    which1 <- strat.fun(var)
    thebase <- ifelse(grepl("Contr", which1), "cw_cont", "cw_diff")
  }
  
  var_tab <- rbind(var_cw_cont, var_ind_cont, var_cw_diff, var_ind_diff)
  var_tab <- cbind (var_tab, c("cw_cont", "ind_cont", "cw_diff", "ind_diff"))
  var_tab[4] <- thebase
  colnames(var_tab)[3:4] <- c("version", "base")
  var_tab[4] <- ifelse(var_tab[[4]] == var_tab[[3]], 1, 0)
  
  return(var_tab)
}

#(trust_tab <- analysis.fun(var='attitude'))
#(in_tab <- analysis.fun('in'))
#con_tab <- analysis.fun('contactOnly')
#r_tab <- analysis.fun(var='rMean')
#pgp_tab <- analysis.fun(var='pgp_amount_end')

```

loop over outcomes.  note: rmean and end_exp don't have index & cw versions. Can still do true.fun1 and true.fun, but cannot do icw and index.

```{r}
# loop over all outcomes
outcome_list <- c("attitude", "in", 'contactOnly',
                  'rMean', "end_exp",
                  "pgp_donate_end", "pgp_amount_end")
newList <- vector(mode="list", length=length(outcome_list))
for(i in 1:length(outcome_list))
{
  newList[[i]] <- analysis.fun(outcome_list[i])
}
save(newList, file="list_of_coefs_and_ps.Rda")
```


****************

Now do it for raw vs binary category vs ranked contact outcomes.

```{r}
table(ag.df$contactOnly_raw_cw)
table(ag.df$contactOnly_cats_cw)
table(ag.df$contactOnly_cw)

var_cw_cont <- true.fun(paste0("contactOnly", "_cw"), 'treatment')
var_cats_cont <- true.fun(paste0("contactOnly_cats", "_cw"), 'treatment')
var_raw_cont <- true.fun(paste0("contactOnly_raw", "_cw"), 'treatment')

var_cw_diff <- true.fun1(paste0("contactOnly", "_cw"), 'treatment')
var_cats_diff <- true.fun1(paste0("contactOnly_cats", "_cw"), 'treatment')
var_raw_diff <- true.fun1(paste0("contactOnly_raw", "_cw"), 'treatment')

var_tab <- rbind(var_cw_cont, var_cats_cont, var_raw_cont, 
                 var_cw_diff, var_cats_diff, var_raw_diff)

```


Now NPC

```{r}
npc <- NPC::NPC(ag.df, tr.var = "treatment", tr.label = 1, 
                    clust.var = "psu", block.var = "state", 
                    y.vars = c("attitude_cw", "in_cw", 'contactOnly_cw',
                  'rMean', "end_exp"), 
                alternative = "greater", test.statistic = "StudentsT",n.perms=10000, seed=952022,
             print.steps=FALSE)
(combP <- npc$p.values['NPC']) # cumulative
npc # all of them

```

*****************

# Intergroup Trust

**attitude**: `r paste(attitudeVars, collapse=", ")`

```{r, eval=F}
lm_robust(attitude_cw ~ treatment, clusters = psu, fixed_effects = state, data = ag.df)
lm_robust(attitude_cw_end ~ treatment + attitude_cw_base, clusters = psu, fixed_effects = state, data = ag.df)

# group
(trust1_farm <- true.fun('allTrust_cw', 'treatment', dat=farmers))
(trust1_past <- true.fun('allTrust_cw', 'treatment', dat=pastors))

# state
lm_robust(allTrust_cw ~ treatment, clusters = psu, data = nas)
lm_robust(allTrust_cw ~ treatment, clusters = psu, data = ben)

# both
lm_robust(allTrust_cw ~ treatment * state, clusters=psu, data=farmers)
lm_robust(allTrust_cw ~ treatment * state, clusters=psu, data=pastors)
```

The coefficient of `r round(trust1$coef,5)` is  `r round(trust1$coef/sd(ag.df$allTrust_cw),3)` standard deviations.

## Insecurity/Violence Effects

```{r}
# select
strat.fun("in_cw_base")
lm_robust(in_cw ~ treatment, clusters = psu, fixed_effects = state, data = ag.df)

# true pvals
(in1 <- true.fun1('in_cw', 'treatment'))
in_ind <- true.fun1('in_index', 'treatment')

# select
strat.fun("vioExp_cw_base")

# both state/group
lm_robust(in_cw ~ treatment * state, clusters=psu, data=farmers)
lm_robust(in_cw ~ treatment * state, clusters=psu, data=pastors)
```


## Contact

Intergroup interaction variables: `r paste(contactVars[c(1:4,7)], collapse=", ")`

```{r con}
strat.fun("contactOnly_cw_base")
(con1 <- true.fun1('contactOnly_cw', 'treatment'))
strat.fun("contactOnly_index_base")
con_ind <- true.fun1('contactOnly_index', 'treatment')

lm_robust(contactOnly_cw ~ treatment, clusters = psu, fixed_effects = state, data = ag.df)

# both state/group
lm_robust(contactOnly_cw ~ treatment * state, clusters=psu, data=farmers)
lm_robust(contactOnly_cw ~ treatment * state, clusters=psu, data=pastors)
```

The coefficient of `r round(con1$coef,5)` is  `r round(con1$coef/sd(ag.df$contactOnly_cw),3)` standard deviations.

**Robustness check** with alternative measure

```{r, eval=F}
strat.fun("contactOnly_cats_cw_base")
(con1.1 <- true.fun1('contactOnly_cats_cw', 'treatment'))
strat.fun("contactOnly_cats_index_base")
con_ind.1 <- true.fun1('contactOnly_cats_index', 'treatment')

```

## PGP -- Group Coordination

### Donation Amount

```{r}
(pgp1 <- true.fun('pgp_amount_end', 'treatment'))
```

Treatment sites donated less.

### Donate yes/no

```{r}
(pgp2 <- true.fun('pgp_donate_end', 'treatment'))
```


## Affect

# Survey Experiments

These all relate to outgroup affect and would probably go somewhere in the outgroup affect category if we didn't include them on their own.


## Rand Exp

Note: this is not a "Randomized Response" experiment, which, similar to a list exp, tries to get honest responses from respondents.  This is an experiment that asks respondents if they would join a group or join a community with **5%/25%/50%/75%** outgroup members.  Higher values means more people say "Yes".  

Each community is assigned their relationship between Outgroup % and "Yes" (how much less likely they are to say "Yes" as outgroup % increases) at baseline and endline.  rand_lm is that relationship at endline - that relationship at baseline.  Higher values good.

```{r rand}
strat.fun("rand_lm_base")
(rand1 <- true.fun1('rand_lm', 'treatment'))
```

There is no difference between treatment and control communities in their willingness to join groups/communities with increasing numbers of outgroup members.

### Rand Exp 2

The analysis of the linear relationship between % outgroup and willingness to join/live fails if the treatment influences _all_ categories, including the lowest 5% category.  To determine if there was a wholesale increase at every category, we can instead analyze the percentage of respondents who say "yes" in treatment comms vs. control comms, blocked by percentage outgroup members and clustered at PSU.

```{r}
strat.fun("rMean_base")
(rand2 <- true.fun1('rMean', 'treatment'))
```

## Endorsement Experiment

```{r end}
strat.fun("end_exp_base")
(end1 <- true.fun('end_exp', 'treatment'))
```

The coefficient of `r round(end1$coef,5)` is  `r round(end1$coef/sd(ag.df$end_exp),3)` standard deviations.


# Placebo

**atts towards violence**: `r paste(vioVars, collapse=", ")`

```{r}
# violence
strat.fun("vio_cw_base")
vio1 <- true.fun1("vio_cw", "treatment")
#true.fun("vio_cw", "treatment")
#true.fun1("vio_index", "treatment")
#true.fun("vio_index", "treatment")
```

No effect.  If there was social desirability bias to tell enumerators what they wanted to hear in TR comms but not CO comms, would probably see it here.


******


# Save 

For combining pvals across levels of analysis.

```{r save1, eval=F}
combP <- GlobP_un
save(ag.df, combP, file="g-aggAnal.Rdata")

```

For referencing these values

```{r save2}
save.image("g-aggAnalComplete.Rdata")
```

For appendices.  chris: need to add con1.1 for alternative contact coding.

```{r save3}
save(trust_ind, in_ind, con_ind,
     vio1,
     threat1, emp1, persp1, expan1,
     file="z_appendices_ag.Rdata")

```